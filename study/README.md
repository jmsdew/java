# 배열

- 동일한 자료형의 묶음
- new 연산자를 사용하여 heap 영역에 공간을 할당한다.
- 반복문을 이용한 연속 처리가 가능하다.
- 연속된 메모리 공간으로 관리할 수 있다.

```java
int[] -- 자료형이 정수인 배열을 선언
int[] array = new int[5];  -- new 연산자를 이용해 5 길이의 공간 할당
```

- int[] array == int array[] 두 가지 모두 선언 할 수 있다.

```java
array = new int[5]; -- 배열을 new로 할당해서 대입할 수 있음.

array[0] = 10; - 하나씩 값 대입 가능

for(int i=0; i<array.length; i++){    -- 반복문을 이용해서 대입 가능
array[i] += 10;
}
```

- 발생한 주소를 참조 변수(레퍼런스 변수)에 저장하여 사용하기 때문에 참조 자료형(레퍼런스 타입) 이라고 한다.


- 변수를 개별적으로 활용하면 생기는 어려움
    1. 변수 명을 다 다르게 만들어 다 따로 관리 해야 하는 어려움이 생긴다.
    2. 모든 정보를 메소드 인자로 호출 시 값을 전달해야 하면 너무 많은 값을 전달해야 해서 한 눈에 안 들어온다.
    3. 리턴은 1개 값만 가능하기 때문에 묶어서 할 수 없다( 자료형이 다름)
    4. 
    
    ```java
    String id = "user01"; String pwd = "pass01";
    String id1 = "user02"; String pwd1 = "pass02"
    ```
    
<br>
<br>
<br>


 # 객체    

- 객체 지향 프로그래밍
    - 현실 세계의 모든 사건은 객체의 상호작용에 의해 일어난다는 세계관을 이용
    - 객체 간의 상호작용을 한다.
    - 모든 객체는 책임을 가지고 자신의 역할을 수행한다.
    - 단일 책임의 원칙으로 하나의 객체가 너무 많은 일을 수행하지 않는다.

- 객체와 객체의 상호작용
    - 객체와 객체는 메세지를 통해 상호작용을 한다.
    - 상호작용에 중요한 것은 메세지를 송수신 하고 그 방법을 기술하여 메세지에 응답하는  상호 방식을 설계하는 것.
    - 메세지를 보내는 쪽 : 송신자, 수신하는 쪽:수신자
    - 메소드 :  수신자가 메세지를 전달 받아 메세지에 해당하는 내용을 순차적으로 처리하는 명령어를 순차적으로 기술한 것.
    - 필드보다는 메소드를 중심으로 추상화 기법을 적용하여 객체를 설계하고, 그 객체를 구현하는 방법으로 설계한 대로 클래스를 작성하는 것.

- 추상화
    - 객체 지향 프로그래밍과 소프트 웨어 공학에서 중요한 개념 중 하나.
    - 복잡한 데이터, 시스템 또한 프로세스를 단순화하거나 요약하여 핵심적인 특징을 강조하고 불필요한 세부 사항을 숨기는 것
    1. 단순화 - 중요한 부분을 남기고 세부적인 부분을 무시한다.
    2. 일반화 - 여러 객체나 개념에서 공통적인 특성을 찾아내어 일반적인 개념으로 표현한다.
    3. 은닉화 - 불필요한 세부 사항을 숨기고 필요한 정보만 노출한다. ( 정보 은닉과 관련이 있음)

자료형

- int A :  원시 자료형 == 기본 자료형 == 프리미티브 타입
    
    주소 값을 스택 영역에 생성한다. 주소 값이 변하지 않는다. ( 값만 바뀜)
    
- Main main; :  참조 자료형 == 레퍼런스 타입
    
    참조 자료형은 선언만 해서는 자리가 생기지 않는다.
    
- main = new Main(); : 값을 할당해 줘야 자리가 생긴다. heap 영역에 생성
    
    참조 자료형은 데이터가 늘어날 수 있다. ( 배열에 내용을 추가하거나 클래스에 내용을 추가할 수 있다.)
    
    - 생성자를 가져와 heap 영역에 값을 할당하기 위해서 참조 자료형을 선언한다.

- 생성자
    - 인스턴스를 생성할 때 초기 수행할 명령이 있는 경우 미리 작성 해두고, 인스턴스를 생성할 때 호출된다.
    - 매개변수가 없는 생성자를 기본 생성자 라고 한다.
    - 기본 성생자는 컴파일러에 의해 자동으로 추가되지만 매개변수가 있는 생성자를 만들면 자동으로 추가되지 않는다.
    
    1. 생성자의 작성 위치
    - 생성자는 문법 상으로 클래스 내부에 작성되며, 필드 선언부와 메소드 선언부 사이에 작성하는 것이 관례적임.
    
    1. 사용 목적
    - 인스턴스 생성 시점에 수행할 명령이 있는 경우 사용
    - 매개변수가 있는 생성자는 매개변수로 전달 받은 값을 필드에 초기화하며 인스턴스를 생성할 목적으로 사용.
    - 작성한 생성자 외에는 인스턴스를 생성하는 방법을 제공하지 않는다.
    - 인스턴스를 생성하는 방법을 제한하기 위한 용도로 사용할 수 있음!
    
    1. 작성시 주의점
    - 생성자 메소드는 클래스의 이름과 반드시 동일해야 함.
    - 생성자 메소드는 반환형을 작성하지 않음. (int void String 등등)
    
    ```java
    public class Main{
    		
    		private int age;
    
    		public Main(){  --- 기본 생성자
    
       	}
    		public Main(int a){    -- 매개변수가 있는 생성자
    			this.age = a;
    
    		}
    
    	}
    
    ```
    

- 오버로딩
    - 다양한 매개변수(파라미터)에 따라 처리해야 하는 메소드를 동일한 이름으로 관리하기 위해서 사용하는 기술
    1. 조건
    - 동일한 이름을 가진 메소드에 매개변수의 타입이나 갯수, 순서를 다르게 작성한다.
    - 시그니쳐가 다르면 다른 메소드로 인식한다.
    - 시그니쳐 중 메소드 이름은 동일해야 하기 때문에 매개변수(파라미터) 선언부가 다르게 작성되어야 오버로딩이 성립된다.
    - 시그니쳐가 달라야 함 → 접근제한자(public private 등)나 반환형(int String void 등)은 성립 요건에 포함되지 않는다.
    
    ```java
    public void [method(int num)]{ ----- 대괄호 부분이 시그니쳐
    
    }
    ```
    

### final

- 종단의 의미를 가지는 키워드
- 키워드를 사용할 수 있는 위치는 다양하지만 결국 변경 불가의 의미이다.

<br>
<br>
<br>

# 컬렉션 프레임워크

- 자바에서 여러 개의 다양한 데이터 들을 쉽고 효과적으로 처리할 수 있게 표준화된 방법을 제공하는 클래스들의 집합을 의미한다.
- 즉, 데이터를 효율적으로 저장하는 자료구조의 데이터를 처리하는 알고리즘으로 미리 구현해 놓은 클래스를 말한다.

## 컬렉션 프레임워크는 크게 3가지 인터페이스 중 하나를 상속

1. List 인터페이스
2. Set 인터페이스
3. Map 인터페이스

## List 인터페이스

- 순서 있는 데이터의 집합으로 데이터의 중복을 허용한다.
- Vector, ArrayList, LinkedList, Stack, Queue 등이 있다.
- 모든 클래스는 요소의 저장 순서가 유지된다.

### ArrayList

- 가장 많이 사용되는 클래스이다.
- 내부적으로 배열을 이용하여 요소를 관리하며, 인덱스를 이용해 배열 요소에 빠르게 접근할 수 있다.
- 배열의 단점을 보완하기 위해 만들어졌다.
- 배열은 크기를 변경할 수 없고, 요소 추가, 삭제, 정렬 등이 복잡하다는 단점을 가지고 있어서
- 크기 변경, 요소의 추가, 삭제, 정렬 기능 들을 미리 메소드로 구현하여 제공한다.
- 하지만 속도가 빨라지는 것은 아니다.

```java
List<String> stringlist = new ArrayList<>();
        stringlist.add("apple");
        stringlist.add("banana");
        stringlist.add("mamgo");
        stringlist.add("orange");
        stringlist.add("grapes");
        stringlist.add(String.valueOf(123));
```

### Iterator(반복자)

- 컬렉션에서 값을 읽어오는 방식을 통일된 방식으로 제공하기 위해 사용한다.
- 반복문을 이용하여 목록을 하나 씩 꺼내오는 방식으로 사용한다.
- hasNext() : 다음 요소를 가지고 있는 경우 true, 없는 경우 false를 반환
- next() : 다음 요소를 반환 후 소멸 ( 1회성)

```java
List<String> descList = new ArrayList<>();
        while(dIter.hasNext()){
            descList.add(dIter.next());
        }
        System.out.println(dIter.hashCode());
        System.out.println(descList);
```

### LinkedList

- ArrayList 가 배열을 이용해서 발생할 수 있는 성능적인 단점을 보완하고자 고안되었다.
- 내부는 이중 연결 리스트로 구성 되어있다.
    - 단일 연결 리스트 : 저장한 요소의 순서를 유지하지 않고 저장되지만 이러한 요소들 사이를 링크로 연결하여 구성해 마치 연결된 리스트의 형태인 것 처럼 만든 구조이다. 하지만 다음 요소만 링크하기 때문에 이전 요소로 접근이 어렵다는 단점이 있다.
    - 이중 연결 리스트 : 이전 요소도 링크하여 이전 요소로 접근하기 쉽게 만들어 졌다.
    
- 역시 List 인터페이스를 상속 받았기 때문에 ArrayList와 사용하는 방법이 유사하다.

### Stack

- list 계열의 Vector 클래스를 상속 받아 구현 되었으며 선형 메모리 공간에 데이터를 저장한다.
- 후입 선출(LIFO : last input first out) 방식의 자료 구조라고 불린다.

```java
Stack<Integer> integerStack = new Stack<>();

        // add push 다 가능함
        integerStack.push(1);
        integerStack.push(2);
        integerStack.push(3);
        integerStack.push(4);
        integerStack.add(5);
        System.out.println(integerStack);

System.out.println(integerStack.search(4));  // 스택에서 요소를 찾을때 이용한다.

```

- 스택에서 값을 꺼내는 메소드는 크게 2가지로 볼 수 있다.
- peek() : 해당 스택의 가장 마지막에 있는(최상단) 요소 반환
- pop() : 해당 스택의 가장 마지막에 있는 요소 반환 후 제거

### LinkedList ( Queue)

- 선형 메모리 공간에 데이터를 저장하는 방식
- 선입 선출 (FIFO : first input first out)
- queue를 상속받은 하위 인터페이스는 다양하지만 , 대부분은 linkedlist를 사용한다.

```java
Queue<String> que = new LinkedList<>();
        que.offer("first");
        que.add("second");
        que.offer("third");
        que.offer("fourth");
        que.offer("fifth");

        System.out.println(que);
```

- peek() : 가장 처음에 들어온 요소를 반환환다.
- poll() : 가장 처음에 들어온 요소를 반환 후 제거한다.

- 요소의 저장 순서를 유지하지 않는다.
- 중복 저장을 허용하지 않는다. ( null도 저장 가능)
 
 <br>
 <br>
 
# SET


## hset

- set 컬렉션 클래스에서 가장 많이 사용되는 클래스
- 알고리즘을 사용하여 검색 속도가 빠르다는 장점을 가진다.

```java
HashSet<String> hset = new HashSet<>();   // 하지만 이렇게 하는게 일반적

        Set hset2 = new HashSet();    //  hashset은 interface set을 상속받음 위 아래 둘 다 가능
                                        // 다형성을 적용할 수 있다.

        hset.add(new String("java"));
        hset.add(new String("jdbc"));
        hset.add(new String("oracle"));
        hset.add(new String("css"));
//        hset.add("java");  값을 기준으로 중복을 허용하지 않는다.
        // 출력 순서가 우리가 등록한 순서와 다르다. (Set은 데이터의 순서를 보장하지 않기 때문이다.)
```

## LinkedHashSet

- hashset ( hset) 이 가지는 모든 기능을 가지고 있다.

<aside>
💡 추가적으로 저장 순서를 유지하는 특징을 가진다.

</aside>

## TreeSet

- 데이터가 정렬된 상태로 저장하는 이진 검색 트리의 형태로 요소를 저장한다.

<img src=./다운로드1.png>

- 데이터를 추가하거나 제거하는 등의 기본 동작 시간이 매우 빠르다.
- set 이 가지는 특징을 그대로 가지지만 정렬된 상태를 유지한다.
<br>
<br>
<br>

# MAP



- key와 value를 하나의 쌍으로 저장하는 방식을 사용한다.

1. key
- 값(value)을 찾기 위한 이름 역할을 하는 객체를 의미한다.
- 요소의 저장 순서를 유지하지 않는다.
- 키는 중복을 허용하지 않지만, 키가 다르면 중복되는 value는 저장이 가능하다.

<aside>
💡 hashmap, hashTable, TreeMap 등의 대표적인 클래스가 있다.

</aside>

- hashmap이 가장 많이 사용된다.

### hashmap

```java
HashMap hmap = new HashMap();  
Map hmap2 = new HashMap();   // 기본적으로 제네릭스 타입 <>  아래 방식으로 많이 개발 함

        hmap.put("one", new Date());
        hmap.put(12, "red apple");
        hmap.put(33, 123);

        System.out.println(hmap);
```

- 동일한 키에 밸류 값을 입력하면 중복되지 않고 덮어 씌운다.

### properties

- hashmap 을 구현하여 사용 용법이 거의 유사하지만, key 와 value 모두 문자열만 사용할 수 있는 자료 구조이다.
- 설정 파일의 값을 읽어서 앱에 적용할 때 사용한다.
